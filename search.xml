<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端ES6（二）ES5中的一些拓展</title>
    <url>/2020/09/11/%E5%89%8D%E7%AB%AFES6%EF%BC%88%E4%BA%8C%EF%BC%89ES5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<h2 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h2><ol>
<li>js对象(数组) –&gt; json对象(数组)：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(obj/arr)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>json对象(数组) –&gt; js对象(数组)：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(json)</span><br></pre></td></tr></table></figure>

<p>上面这两个方法是ES5中提供的。</p>
<p>我们要记住，我们通常说的“json字符串”，只有两种：<strong>json对象、json数组</strong></p>
<p>typeof json字符串的返回结果是string。</p>
<h2 id="Object的扩展"><a href="#Object的扩展" class="headerlink" title="Object的扩展"></a>Object的扩展</h2><p>ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(prototype,[descriptors])</span><br></pre></td></tr></table></figure>

<p>作用：以指定对象为原型，创建新的对象。同时，第二个参数可以为新的对象添加新的属性，并对此属性进行描述。</p>
<p><strong>举例1</strong>：（没有第二个参数时）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="attr">username</span>:<span class="string">'smyhvae'</span>,<span class="attr">age</span>:<span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="attr">address</span>:<span class="string">'beijing'</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj2=<span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(Obj2);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="E:%5Cworkspace%5CblogPrivate%5Csource_posts%5Cimage%5C20180401_2150.png" alt="img"></p>
<p>我们发现，obj1成为obj2的原型。</p>
<p><strong>举例2</strong>：（有第二个参数时）</p>
<p>第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新的属性‘sex’：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">username</span>: <span class="string">'smyhvae'</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">address</span>: <span class="string">'shenzhen'</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj2 = <span class="built_in">Object</span>.create(obj1, &#123;</span><br><span class="line">        sex: &#123;<span class="comment">//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉</span></span><br><span class="line">            value: <span class="string">'男'</span>,  <span class="comment">//通过value关键字设置sex的属性值</span></span><br><span class="line">            writable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>

<p>上方代码中，我们通常第5行的sex给obj2设置了一个新的属性‘sex’，但是要通过‘value’来设置属性值（第6行）。</p>
<p>设置完属性值后，这个属性值默认是不可修改的，要通过‘writable’来设置。总而言之，这几个关键字的解释如下：</p>
<ul>
<li><code>value</code>：设置属性值。</li>
<li><code>writable</code>：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。</li>
<li><code>configurable</code>：标识当前属性是否可以被删除。默认为false，不可删除。</li>
<li><code>enumerable</code>：标识当前属性是否能用 for in 枚举。 默认为false，不可。</li>
</ul>
<h4 id="单独设置属性"><a href="#单独设置属性" class="headerlink" title="单独设置属性"></a>单独设置属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> defineProperty(obj2,<span class="string">'sex'</span>,&#123;</span><br><span class="line">   value:<span class="string">'cc'</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote>
<p>这个方法有点难理解。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(object,descriptors)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：为指定对象定义扩展多个属性。</p>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    firstName:<span class="string">'smyh'</span>,</span><br><span class="line">    lastName:<span class="string">'vae'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj2,&#123;</span><br><span class="line">    fullName:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.this.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(data)&#123;<span class="comment">//监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数</span></span><br><span class="line">            <span class="keyword">var</span> names = data.split(<span class="string">'-'</span>);</span><br><span class="line">            <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.firstName = <span class="string">'tim'</span>;</span><br><span class="line">obj2.lastName = <span class="string">'duncan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.fullName = <span class="string">'kobe-bryant'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br></pre></td></tr></table></figure>

<ul>
<li>get ：用来获取当前属性值的回调函数</li>
<li>set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值</li>
</ul>
<p>存取器属性：setter，getter一个用来存值，一个用来取值。</p>
<h2 id="Object的扩展（二）"><a href="#Object的扩展（二）" class="headerlink" title="Object的扩展（二）"></a>Object的扩展（二）</h2><p>obj对象本身就自带了两个方法。格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> 属性名()&#123;&#125; 用来得到当前属性值的回调函数</span><br><span class="line"><span class="keyword">set</span> 属性名()&#123;&#125; 用来监视当前属性值变化的回调函数</span><br></pre></td></tr></table></figure>

<p>举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    firstName : <span class="string">'kobe'</span>,</span><br><span class="line">    lastName : <span class="string">'bryant'</span>,</span><br><span class="line">    <span class="keyword">get</span> fullName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> fullName(data)&#123;</span><br><span class="line">        <span class="keyword">var</span> names = data.split(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName);</span><br><span class="line">obj.fullName = <span class="string">'curry stephen'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName);</span><br></pre></td></tr></table></figure>

<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><blockquote>
<p>下面讲的这几个方法，都是给数组的实例用的。</p>
</blockquote>
<p><strong>方法1</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.indexof(value)</span><br></pre></td></tr></table></figure>

<p>作用：获取value在数组中的第一个下标。</p>
<p><strong>方法2</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.lastIndexOf(value)</span><br></pre></td></tr></table></figure>

<p>作用：获取 value 在数组中的最后一个下标。</p>
<p><strong>方法3</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>方法4</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>作用：遍历数组返回一个新的数组，返回的是<strong>加工之后</strong>的新数组。</p>
<p><strong>方法5</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>作用：遍历过滤出一个新的子数组，返回条件为true的值。</p>
<h2 id="函数function的扩展：bind"><a href="#函数function的扩展：bind" class="headerlink" title="函数function的扩展：bind()"></a>函数function的扩展：bind()</h2><blockquote>
<p>ES5中新增了bind()函数来改变this的指向。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind(obj)</span><br></pre></td></tr></table></figure>

<p>作用：将函数内的this绑定为obj，并将函数返回。</p>
<p><strong>面试题</strong>：call()、apply()和bind()的区别：</p>
<ul>
<li>都能改变this的指向</li>
<li>call()/apply()是<strong>立即调用函数</strong></li>
<li>bind()：绑定完this后，不会立即调用当前函数，而是<strong>将函数返回</strong>，因此后面还需要再加<code>()</code>才能调用。</li>
</ul>
<p>PS：bind()传参的方式和call()一样。</p>
<p><strong>分析</strong></p>
<p>为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。</p>
<p>bind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端ES6（一）ES5中的严格模式</title>
    <url>/2020/09/10/%E5%89%8D%E7%AB%AFES6%EF%BC%88%E4%B8%80%EF%BC%89ES5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="ES的几个重要版本"><a href="#ES的几个重要版本" class="headerlink" title="ES的几个重要版本"></a>ES的几个重要版本</h2><ul>
<li>ES5：09年发布。</li>
<li>ES6(ES2015)：2015年发布，也称为ECMA2015。</li>
<li>ES7(ES2016)：2016年发布，也称为ECMA2016（变化不大）。</li>
</ul>
<h2 id="严格模式的理解"><a href="#严格模式的理解" class="headerlink" title="严格模式的理解"></a>严格模式的理解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>理解</strong>：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：”严格模式”（strict mode）。</p>
<p>顾名思义，这种模式使得Javascript在更严格的语法条件下运行。</p>
<p><strong>目的</strong>：</p>
<ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，为代码的安全运行保驾护航</li>
<li>为未来新版本的Javascript做好铺垫</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>针对整个脚本文件：将<code>use strict</code>放在脚本文件的第一行，则整个脚本文件将以严格模式运行。</li>
<li>针对单个函数：将<code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</li>
</ul>
<p>PS：如果浏览器不支持，则这句话只解析为一条简单的语句，没有任何副作用。</p>
<p>甲苯文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p>
<h3 id="语法和应为改变"><a href="#语法和应为改变" class="headerlink" title="语法和应为改变"></a>语法和应为改变</h3><ul>
<li>必须用var声明变量</li>
<li>禁止自定义的函数中的this指向window</li>
<li>对象不能有重名的属性</li>
</ul>
<h2 id="严格模式和普通模式的区别"><a href="#严格模式和普通模式的区别" class="headerlink" title="严格模式和普通模式的区别"></a>严格模式和普通模式的区别</h2><blockquote>
<p>下面列举几条严格模式的内容。</p>
</blockquote>
<h3 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h3><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<h4 id="禁止this关键字指向全局对象"><a href="#禁止this关键字指向全局对象" class="headerlink" title="禁止this关键字指向全局对象"></a>禁止this关键字指向全局对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>上方代码中，普通模式打印的是window。严格模式下打印的是undefined。</p>
<h4 id="构造函数必须通过new实例化对象"><a href="#构造函数必须通过new实例化对象" class="headerlink" title="构造函数必须通过new实例化对象"></a>构造函数必须通过new实例化对象</h4><p>构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p>
<p>比如说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat=<span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat(<span class="string">'haha'</span>);</span><br></pre></td></tr></table></figure>

<p>上方代码中，如果再严格模式下，则会报错。</p>
<h4 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h4><p>普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p>
<p>普通模式下，如果函数有多个重名的参数，可以用argument[i]读取。严格模式下，多个重名的参数属于语法错误。</p>
<p>比如下面这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    username:<span class="string">'smyh'</span>;</span><br><span class="line">    username:<span class="string">'vae'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，在严格模式下属于语法错误，因为有重名的属性。</p>
<h4 id="函数必须声明在顶层"><a href="#函数必须声明在顶层" class="headerlink" title="函数必须声明在顶层"></a>函数必须声明在顶层</h4><p>将来JavaScript的新版本会引入“块级作用域”。为了和新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<h4 id="新增关键字"><a href="#新增关键字" class="headerlink" title="新增关键字"></a>新增关键字</h4><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p>
]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
</search>
